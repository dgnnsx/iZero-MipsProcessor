module ULA(aluOp, A, B, immediate, shift, result, above, equal, below);

// ----------Input Ports---------- //
input [3:0] aluOp;
input [31:0] A;
input [31:0] B;
input [31:0] immediate;

// ----------Output Ports---------- //
output reg [31:0] result;
output reg above;
output reg equal;
output reg below;

always @ (AluOp or A or B) begin
	case(aluOp[3:0])
	
		// -----Arithmetics----- //
		4'b0000: result = A + B; // ADD Registers
		4'b0001: result = A + immediate; // ADD Immediate
		4'b0010: result = A - B; // SUB Registers
		4'b0011: result = A - immediate; // SUB Immediate
		
		// -----Logics----- //
		4'b0100: result = A & B; // AND Registers
		4'b0101: result = A & immediate; // AND Immediate
		4'b0110: result = A | B; // OR	Registers
		4'b0111: result = A | immediate; // OR Immediate 
		4'b1000: result = A ^ B; // XOR Registers
		4'b1001: result = A ^ immediate; // XOR Immediate
		4'b1010: result = ~A; // NOT first register
		4'b1011: result = ~B; // NOT second register
		
		// -----Shifts----- //
		4'b1100: result = A << shift; // SHIFT LEFT x bits
		4'b1101: result = B >> shift; // SHIFT RIGHT x bits
		
		default: Result = 32'b0;		
	endcase
	
	if(A == B)
		equal <= 1'b1;
	else
		equal <= 1'b0;
		
	if(A > B)
		above <= 1'b1;
	else
		above <= 1'b0;
		
	if(A < B)
		below <= 1'b1;
	else
		below <= 1'b0;
		
	end
endmodule
	