module unidade_de_controle();

	input clock;
	input reset;
	input [5:0] opcode;
	
	
	// FLAGS DE CONTROLE
	
	// multiplexadores
	output reg muxULA;
	output reg muxInstrucao;
	output reg muxPC; // talvez ~n precise
	
	// controle ULA
	output reg [3:0] ula_controle;
	
	// controles de leitura / escrita / reset
	output reg pc_escrita;
	output reg pc_reset;
	output reg reg_escrita;
	//output reg reg_reset; // talvez ~n precise
	output reg md_escrita;
	output reg md_leitura;
	
	
	// declaracao das instrucoes
	
	
	// OPCODE das instrucoes aritmeticas, logicas e de deslocamento
	localparam [5:0] 	ADD = 6'b000001, ADDI = 6'b000010, SUB = 6'b000011, SUBI = 6'b000100,
							AND = 6'b000101, ANDI = 6'b000110, OR = 6'b000111, ORI = 6'b001000, XOR = 6'b001001, XORI = 6'b001010, NOT = 6'b001011,
							SL = 6'b001100, SR = 6'b001101,
							MOV = 6'b001110;
							
							
	// OPCODE das instrucoes de transferencia
	localparam [5:0] LOAD = 6'b100000, LOADI = 6'b100001, STORE = 6'b100010;

	// OPCODE das instrucoes de entrada e saida
	localparam [5:0] IN = 6'b100011, OUT = 6'b100100;
		
	
	// OPCODE das instrucoes de controle do sistema
	localparam [5:0] HALT = 6'b000000, RESET = 6'b111111;
	
	always @ (posedge clock) begin
		case(opcode)
			ADD: begin
				ula_controle = 4'b0000;
				pc_escrita = 1'b0;
				// pc_reset = 1'b0;
				reg_escrita = 1'b1;
				md_escrita = 1'b0;
				md_leitura = 1'b0;		
			
			end
			ADDI: begin
				ula_controle = 4'b0001;
				pc_escrita = 1'b0;
				reg_escrita = 1'b1;
				md_escrita = 1'b0;
				md_leitura = 1'b0;	
			
			end
			SUB: begin
				ula_controle = 4'b0010;
				pc_escrita = 1'b0;
				reg_escrita = 1'b1;
				md_escrita = 1'b0;
				md_leitura = 1'b0;
			
			end
			
			SUBI: begin
				ula_controle = 4'b0011;
				pc_escrita = 1'b0;
				reg_escrita = 1'b1;
				md_escrita = 1'b0;
				md_leitura = 1'b0;
			
			end
			AND: begin
			
			end
		
		
		endcase
			
	end
	
endmodule
